## JavaScript

### [On the Road to Better Sourcemaps in the Firefox Developer Tools](http://jlongster.com/On-the-Road-to-Better-Sourcemaps-in-the-Firefox-Developer-Tools)

* The debugger already has sourcemap support. The problem, though, is that other places that link to the source code are not aware of this info.
* The debugger was only connected when necessary to avoid overhead, and by then it's the only component that could access sourcemap data. You can't just go fetch the map, because you could not get it to work with scripts generated by `eval()` - what's the point to go down this path if it only means limited support?
* Previouly when the debugging mode is triggered, **all the code** would be demoted to be compiled by the baseline compiler(the optimizing compiler Ion doesn't have the info the debugger needs)
* The solution is **on-stack deoptimization**(a technique previously used by, of course, Self). With [Bug 716647 - allow Debugger to be enabled with debuggee frames on the stack](https://bugzilla.mozilla.org/show_bug.cgi?id=716647), only the related code will be demoted.
* Now that the debugger is connected immediately when devtools opens([Bug 1132501 - Turn on the debugger whenever the devtools are opened](https://bugzilla.mozilla.org/show_bug.cgi?id=1132501)), the sourcemap info is available everywhere.

### [Debugging in the Time of JITs](http://rfrn.org/~shu/2014/05/14/debugging-in-the-time-of-jits.html)

#### The Problem

* SpiderMonkey's implmenetation: disable JIT in debug mode
* Must wait for the JS execution stack to be empty to turn on debugging
* Solution: debug mode OSR
  * Deoptimize and recompile JITed code on the stack, patching the return addresses as we go
  * Taken from Self's [Debugging Optimized Code with Dynamic Deoptimization](http://bibliography.selflanguage.org/_static/dynamic-deoptimization.pdf)

#### Debugger Hooks

* [The Debugger Interface](https://developer.mozilla.org/en-US/docs/Tools/Debugger-API) of SpiderMonkey makes it possible to implement a JS debugger in JS
* It reflects the engine structures(frames, scripts, scopes)
* Provide hooks(e.g. `onStep`/`onPop` on a frame) for JS callbacks
* During execution, the engine checks for hooks to be called

#### `onStep`

* In SpiderMonkey, all scripts are compiled into bytecode before execution. `onStep` in SpiderMonkey means to add `call onStep` after every bytecode
* In the interpreter, these `call onStep` will all be executed.
* In the Baseline JIT, they will **only be compiled when explicitly requested**(support them but can't be turned on on-the-fly)
* IonMonkey just doesn't support them, at all
* So the debugging request must be made up front because SpiderMonkey couldn't turn on debug mode with live JS on the stack, since they are not compiled with support of the instructions
* Solution
  * Baseline: on-stack recompilation
  * Ion: on-stack deoptimization, and bailed out to Baseline

#### Deoptimization & Rematerialization

* The Ion frame on the stack should be **overwritten with a reconstructed Baseline frame** corresponding to the same location in which Ion code is currently executing
* Luckily, almost any optimizing JIT compiler support on-stack deoptimization becase they always need to bail out to another tier
* Baseline **does not inline calls**, and requires every frame to be visible. The debugger API requires this too.
  * Bailing out the baseline means to reconstruct those inlined frames
* Ion's *snapshots*(bookkeeping info) can be used to reconstruct inline frames
* To avoid the situation where there's not enough stack space to rewrite an Ion frame into one or more baseline frames, bailing out from Ion into Baseline is only possible for the **youngest frame on the stack**. That is, **deoptimization is lazy**
* *Rematerialization* is the process of copying the machine state into a heap-allocated structure with the help of snapshots, for making optimized frames(possibly with code inlined and slots in the registers instead of on the stack) visible to the Debugger API
* Rematerialized frames can be modified during execution, so they act as a **write-back cache for frame slots** - they will be written back upon bailout to the reconstructed Baseline frame

#### Recompilation

* Scripts compilled in Baseline or promoted from Baseline to Ion still have unhandled Baseline frames on the stack. We need to recompile them and patch those frames.
* If we see stack structure of scripts compiled with debug mode on/off as the same(to simplify), then **recompilation is a degenerate case of deoptimization**
  * Deoptimization: applies Ion-to-Baseline transform, jumps to the recompiled Baseline code
  * Recompilation: applies identity transform, then jumps to the recompiled Baseline code
  * Both are control operations that **edit their own continuations**
* The Baseline JIT compiles inline caches for most bytecode operations, and install call ICs for function calls
* These IC starts with a fallback path and add new inline paths(**stubs**) during the execution. These stubs have their own frame on the stack

#### Baseline frames, stub frames, IC entries

* A Baseline frame(storing fixed/stack slots -> local/temporary vairables) + a Baseline **stub frame**(does the catual call)
* The stub frame is the IC frame
* To call `mod2(x)`, we must
  * First, call into a `CallIC` stub
    * Sets up the frame
    * The return address pushed onto the Baseline frame is into the main Baseline code
  * Then the stub calls into `mod2`.
    * The return address pushed onto the stub frame is into the `CallIC` stub code
* The stub frame contains a pointer to a data structure
  * Stored at the end of the Baseline code
  * Contains all the metadata for the IC operation
  * Has an **IC entry** that has the pointers to all its stubs(an IC can have multiple stubs(type specialized))
  * The IC Entry can also be addressed directly by machine code address/bytecode offset
* After the recompilation
  * Pointers to the old Baseline code/the stub data at the end of it are now **invalid**(dangling)
  * The address/offset of the IC entry is still the same in the new Baseline code, so it's still **valid**
  * The stub codes are shared across scripts, and are not affected by the recompilation. They are still **valid**, and the new Baseline code will still have a pointer to them in its IC entry
* Our job, then, is to **update all the dangling pointers** that point to the old, destroyed Baseline code, to the new Baseline code generated y recompilation
* Note there are more kinds of ICs other than `CallIC`
