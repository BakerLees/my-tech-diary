## [The Future of TypeScript: ECMAScript 6, Async/Await and Richer Libraries](https://channel9.msdn.com/Events/Build/2015/3-644)

* Static types and future ES
* Optional typing, tooling lights up during annotation, completion, documentaton, refectoring, definitions and references
* TSD files(like .h files) and [Definitely types](https://github.com/borisyankov/DefinitelyTyped)
* Angular 2 and AtScript
* Different compile targets: ES3, ES5, ES6
* Infers types and recognizes type guards
* Type checking goes away in compiled code
* TS Server(using node) talks to editors/plugins with a JSON protocol. You don't need to write the parser and semantics analyzer youself.
* TS 2.0: later this year, 100% ES6 compliance


##[Whatâ€™s New in JavaScript for Fast and Scalable Apps](https://channel9.msdn.com/Events/Build/2015/2-763)

### Arrow functions
* lexical `this`, `arguments` and `super`
* Gotcha: Blocks(`let`+curly braces) needs explicit `return`(inside the curly braces)
  * This

    ```javascript
    let wat = () => {name: 'blah'};
    console.log(wat());
    ```
    will give you `undefined`, you need to `return`:

    ```javascript
    let wat = () => {return {name: 'blah'}};
    console.log(wat());
    ```
    or use parentheses to tell the interpreter that you are giving an expression:
    ```javascript
    let wat = () => ({name: 'blah'});
    console.log(wat());
    ```

### Iterators

Lazy evaluations! Yay!

You need to implement:
1. `[Symbol.iterator]()`
2. `next()`, `throw()`, `catch()` for the thing returned by `[Symbol.iterator]()`(usually it is `this` so that you can access the data in the object)
3. `next()`, `throw()`, `catch()` need to return an object that has `done` and `value`;

My Example:

```javascript
// ------------ Implement it!
function Stack(arr) {
  this.storage = arr ? arr.slice(0) : [];
}

Stack.prototype.push = function(value) {
  this.storage.push(value);
  return this;
}

Stack.prototype.pop = function() {
  return this.storage.pop();
}

Stack.prototype[Symbol.iterator] = function() {
  return this;
}

Stack.prototype.next = function() {
  var done = (this.storage.length === 0);
  if (done) return {done: done};
  else return {value: this.pop(), done: done}
}

// ---------- Use it!
// for-of
var foo = new Stack([1, 2, 3, 4]);
for (var i of foo) {
  console.log(i);  // 4,3,2,1
}

// spread operator
var bar = new Stack([1, 2, 3, 4]);
var baz = [1, 2, ...bar];  // [ 1, 2, 4, 3, 2, 1 ]

// Array.from
var barfoo = new Stack([1, 2, 3, 4]);
var foobar = Array.from(barfoo); // [ 4, 3, 2, 1 ]
```

* `Map` and `Set` accept iterables in their constructor.
* `Array.prototype.values()` returns iterable
* `Map.prototype.values()`, `Map.prototype.keys()`,`Map.prototype.entries()`  return iterable
* `Set.prototype.values()` returns iterable

### Generators

Suspend on `yield`, like python.

```javascript

function asyncOperation() {
  return new Promise(resolve => {
    setTimeout(function() {
      resolve(Math.random());
    }, Math.random() * 3000);
  });
}

function syncOperation(value) {
  console.log(value);
}

function spawn(gen) {
  return new Promise(resolve => { 
    let iter = gen();  // get the iterator out of the generator
  
    function tick(v) {
      let cur = iter.next(v);  // spread it out
      if (cur.done) {
        resolve(cur.value);
      } else {
        cur.value.then(tick);  // pass the async result to tick
      }
    }

    tick();
  });
}

spawn(function* () {
  console.log("start");

  // what passed to next() will be yielded here
  let a = yield asyncOperation();
  syncOperation("first async result: " + a);
  let b = yield asyncOperation();
  syncOperation("second async result: " + b);
  let c = yield asyncOperation();
  syncOperation("second async result: " + c);

  console.log("done");
  return a + b + c;  // this will be resolved
}).then(result => console.log("Final result: " + result));
```

async/await sugars will be in ES7.

### asm.js

* Tight, optimizable, low-level subset of JavaScript
* Not suitable for hand writing but as a compiler target
* Compile AOT, no JIT, not bailouts
* Aggressive optmizations, close to native performance

### SIMD

Single Instruction, Multiple Data: Hardware instructions for batch calculations

Good at RGB/A and  XYZW coordinates opeartions, map-like operations on array, etc.

Better performance, lower power cosumption