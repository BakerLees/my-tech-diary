## Learning Modern 3D Graphics Programming

[Reddit](http://www.reddit.com/r/programming/comments/muoof/learning_modern_3d_graphics_programming/)

### CH1 Basics

#### Graphics and Rendering
* In rasterizers, all objects that you see are **empty shells**. All of these shells are made of triangles(some might use planar quadrilaterals).
  * Why triangles? Because the lines are guaranteed to be on the **same plane**.
* Objects are made out of adjacent triangles that define the outer surface of the object -- mesh/model/geometry.
* Pipeline: triangles in, 2D image(pixels) out.
  * One triangle at a time, in a specific order.
  * Different triangles, different phases, one after another. Hence it is a pipeline.
* The order in which triangles and the various meshes are submitted to the rasterizer can affect its output.
* OpenGL is an API for **accessing a hardware-based rasterizer

#### Pipeline
* Clipping & clip coordinates
  * Volume - clip space, clip coordinates
  * (x, y, z, w) for clip coordinates.
  * w is the extent of clip space, which ranges in [-W, W]
  * Clipping - transform triangles partially outside of the clip space into smaller triangles entirely within the space
* Normalized device coordinates
  * Divide x, y, z by w
  * [-1, 1]
* Window coordinates
  * Bounds depends of the size of the viewport
  * z in [0, 1], vertices with z > 1 will not be seen
* Scan Conversion
  * A triangle will produce a fragment for every pixel sample that is within the 2D area of the triangle
  * OpenGL guarentees that triangles sharing an edge will not have gaps
  * Result: a sequence of fragments that cover the shape of the triangle
  * Fragments are associated with data containig 2D location of the fragment in window coordinates, as well as the Z position of the fragment(depth). 
* Fragment Processing
  * Takes a fragment, generate one or more color values and a single depth value
  * Fragments of the same triangle must be processed together
* Fragment Writing
  * Colors and depth might be combined with the current color of the image. Fragments are not necessarily all turrned into pixels

## Browsers

### [DOM Attributes now on the prototype chain](http://updates.html5rocks.com/2015/04/DOM-attributes-now-on-the-prototype)

* Now Chrome, IE and Firefox behaves the same
* Helps to implement getters/setters
* Polyfill

#### Changes

1. `hasOwnProperty` on DOM object

  ```javascript
  div.hasOwnProperty("isContentEditable");
  ```
  returns `false` now, but

  ```javascript
  HTMLElement.prototype.hasOwnProperty("isContentEditable");
  ```
  returns `true`. It is recommended to use:

  ```javascript
  if("isContentEditable" in div) {
    //...
  }
  ```
2. `Object.getOwnPropertyDescriptor` will only work on DOM object prototypes, not on DOM obejct instances
3. Since `JSON.stringify` doesn't serialize properties on the prototype, `JSON.stringify(domObject)` will no longer contain DOM properties(most of the time this should be `"{}"`). You can use for-in loop to do deep copy and serialize it.
4. Writing to read-only properties in strict mode will throw an error

### How do browsers implement font fallback