## C++

### [Bjarne Stroustrup - The Essence of C++](https://www.youtube.com/watch?v=D5MEsboj9Fc)

#### What C++ is/was designed with in mind

* Type safety
* Resource safety
* Performance
* Predictability
* Teachability
* Readability

#### What is/was C++ for

* System programming
* Embedded systems
* Resource constrained systems
* Large systems

#### What does C++ offer

1. Map to hardware(the C part)
  * values, handles
2. Classes
  * Construction/destruction
3. Inheritance
  * Abstraction(virtual), insulation from implementation
  * Data in derived classes, interfaces in abstract classes
  * Needs dynamic memory/resource management
4. Generic programming
  * Templates are about GP first, MP second.


#### What's not C++

* GC
* Guarantee for type safety
  * Compatibility for C needs to break type safety
* VM
  * What will be used to implement a VM anyway? :)
* Huge standard library
  * No sugar daddy, no central authority
* Standards(for applications)

#### Resource management

* Resources -- handles
  * Memory(containers), locks, files, sockets, threads...
* Constructors and destructors
* Handles are usually scoped, so its lifetime is predictable
* Needs to be required and release, needs an owner
* RAII: acquisition is initialization
  * Acquire in construction, Release in destruction
* Throw exception in case of failure
* Never throw while holding a resource not owned by a handle
  * E.g. allocate memory for a local raw pointer, then throw/return without deletion
* In general, leave established invariants intact when leaving a scope

#### Comparisons

Raw pointer:

```
void fn(int n, int x) {
  Gadget *p = new Gadget{n};
  if (x < 100) throw std::runtime_error{"Oh!"}; // leak
  if (x < 200) return; // leak
  delete p;  // may or may not be executed
}
```

Smart pointer(leaving the local scope will reclaim the resource):

```
void fn(int n, int x) {
  std::shared_ptr<Gadget> p{new Gadget{n}};
  if (x < 100) throw std::runtime_error{"Oh!"}; // no leak
  if (x < 200) return; // no leak
  delete p;  // may or may not be executed
}
```

`shared_ptr` is a form of GC, but if you don't want GC, try `unique_ptr` when you are not sharing.

But why do you even need pointers?

```
void fn(int n, int x) {
  Gadget g{n};
  if (x < 100) throw std::runtime_error{"Oh!"}; // no leak
  if (x < 200) return; // no leak
  delete p;  // may or may not be executed
}
```

Use scoped variables instead of pointers whenever you can.

#### What are pointers/references/iterators for?

* Reference resources from **within a handle**
  * Handles are things that you don't need to worry about its resource management, e.g. smart pointer(so typically they overload `->` and `*`)
* Positions(careful)
* For **passing** large amount of data e.g. const reference

* Not for ownership!
* Not for **returning** large amount of data!
  * Use move operations instead.

#### How to get a lot of data cheaply out of a function

1. Return a pointer to a `new`ed object
  * Problem: who does the `delete`?
2. Return a reference to a `new`ed object
  * Problem: who does the `delete`? Delete what?
3. Pass a target object
  * Are you from the Stone Age?
  * Source of confusion
4. Return an object(typically with RVO)
  * Copies are expensive
  * Tricky to avoid copying
5. Solution: return a handle!
  1. Return a Matrix
  2. Define move constructor for Matrix
    * Steal the internal pointer, put a nullptr in the old object

#### Principles for managing resources

1. Store data in containers
2. Manage all resources with handles
  * RAII
  * Remember sockets, file handles, etc.
3. Use smart pointers
4. Plugin a GC

BS have implemented `auto` in the 1990s but he took it out for compatibility reasons


#### Class Hierarchies

* Protection model
  * `public` - all users
  * `protected` - derived classes
  * `private` - own members
* Why no universal base class
  * The concept is not reasonable itself
  * Unnecessary, implementation-oriented
  * Space and time overheads
  * Underspecified(overly general) interfaces
* Multiple inheritance
  * Abstract classes provide the most stable interfaces
* Minimal runtime type identification
  * `dynamic_cast<D*>(p)`
  * `typeid(p)`
* Only use inheritance when
  * The domain concepts are hierarchical
  * There is a need for **run-time selection** among the alternatives
* Think before you make a thing a member

### Generic Programming

* Aims
  * General/flexible
  * Zero-overhead: vector/matrix v.s. C arrays
  * Well-specified interfaces(Not achieved)
* Templates - compile-time duck typing

  > I used to think that sooner or later the compiler writers would become smart enough to write decent error messages, but it hasn't happened


## Graphics

### [Vector Graphics Animation with Time-Varying Topology (SIGGRAPH 2015)](https://www.youtube.com/watch?v=Xk1_CugdytI)

This is really impressive...

Paper: [](http://www.dalboris.com/research/vac/vac.pdf)