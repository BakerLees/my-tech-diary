## OS

### [select / poll / epoll: practical difference for system architects](http://www.ulduzsoft.com/2014/01/select-poll-epoll-practical-difference-for-system-architects/)

#### select

* Been around for a long time(since 1983)
* Not in the first POSIX spec since by then there was no such thing as non-blocking I/O
* **Usage**: fill up some `fd_set` with descriptors and events and call `select()` with them

  ```cpp
  // Reset the sets
  FD_ZERO( &fd_in );
  FD_ZERO( &fd_out );
   
  // Monitor for input/output events
  FD_SET( socket1, &fd_in );
  FD_SET( socket2, &fd_out );

  // Call the select
  int largest_fd = socket1 > socket2 ? socket1 : socket2;
  int ret = select( largest_fd + 1, &fd_in, &fd_out, NULL, &tv );
   
  // Check if select actually succeed
  if ( ret == -1 ) {
      // report error and abort
  } else if ( ret == 0 ) {
      // timeout; no event detected
  } else {
      if ( FD_ISSET( socket1, &fd_in ) )
          // input event on stdin
   
      if ( FD_ISSET( socket2, &fd_out ) )
          // output event on stdout

      // ... if you have more descriptors, you need to check each one of them!
  }
  ```
* **Flaws**
  * Can't **reuse** `fd_set` that you pass into it, `select` will overwrite it every single time, so you need to refill it every time you call `select`
  * When it returns, you need to **manually** check every descriptor with `FD_ISSET`
  * Number of descriptors is limited
  * Not suited for **multi-threaded** environments -- "If a file descriptor being monitored by `select()` is closed in another thread, the result is **unspecified**"(WTF?!)
  * It periodically checks the descriptors(typically scanning a bit vector), which wastes CPU cycles
* **Why it's still used**
  * Portability - it's been around everywhere
  * Handle timeouts within one **ns** precision(`poll` and `epoll` can only handle one **ms**)
* **Note**
  * Disk files are **always ready to read** (but the read might return 0 bytes if you're already at the end of the file), so you can't use `select()` on a disk file to find out when new data is added to the file

#### poll

* Appeared in 1986, introduced in Linux since 1997(2.1.23)
* Why it's "better"
  * `select()` can't handle many descriptors because its implementation (usually) uses fixed-size bitmasks, but `poll()` (usually) uses linked list(wait queue) so it can handle **much more descriptors**
  * `poll()` can reuse the descriptors(but you need to set `fd.revents = 0`)
  * Can monitor more events than `select()`
* **Usage**: fill some `struct pollfd` and call `poll()` with them

  ```cpp
  // fill some fds
  struct pollfd fds[2];
  fds[0].fd = socket1;
  fds[0].events = POLLIN;  /* event interested in */
  fds[1].fd = socket2;
  fds[1].events = POLLOUT;
   
  // Timeout in 10s
  int ret = poll( &fds, 2, 10000 );

  // Check if poll actually succeed
  if ( ret == -1 ) {
      // report error and abort
  } else if ( ret == 0 ) {
      // timeout; no event detected
  } else {
      // If we detect the event, zero it out so we can **reuse** the structure
      if ( fds[0].revents & POLLIN ) /* event actually happened */
          fds[0].revents = 0;
          // input event on sock1

      if ( fds[1].revents & POLLOUT )
          fds[1].revents = 0;
          // output event on sock2
  }
  ```
* **Flaws**
  * `poll()` can only has ms-precision, while `select()` has ns
  * Not in Windows older than Vista, but you can do this

    ```cpp
    #if defined (WIN32)
    static inline int poll( struct pollfd *pfd, int nfds, int timeout) { return WSAPoll ( pfd, nfds, timeout ); }
    #endif
    ```
  * You still need to manually check each descriptor for events/set up event monitors
  * Still has unspecified behavior for multithreaded environment(e.g. close a monitored socket)
* Note
  * If it's just a choice between `poll()` and `select()`, **only** use `select()` instead of `poll()` when
    * You need to support systems that don't have `poll()`
    * You need ns-precision(which is rare)
  * But, most of the times `epoll()` is a better choice

#### epoll

* Note
  * When you will choose `poll()` over `epoll()`
    * You need to support systems that don't have `epoll()`(Linux-only) and don't have wrappers(e.g. for FreeBSD `kqueue` /Windows `ICOP`)
  * When there's no significant benefit for choosing `epoll()` over `poll`
    * < 1000 sockets
    * > 1000 sockets but the connections are short-lived
    * No conflicting operation in other threads
