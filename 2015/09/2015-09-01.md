## ES6

### [ES6 In Depth: Subclassing](https://hacks.mozilla.org/2015/08/es6-in-depth-subclassing/)

* You can use `Object.setPrototypeOf()` after you declare a class, but it's less performant and less optimizable for engines

    ```javascript
    // Hook up the instance properties
    Object.setPrototypeOf(Circle.prototype, Shape.prototype);

    // Hook up the static properties
    Object.setPrototypeOf(Circle, Shape);
    ```
* In ES6, we now have `extends`.

    ```
     class Circle extends Shape {
        // ...
    }
    ```
* You can `extends` any expression as long as it's **a valid function with a `.protoytpe`**. e.g.
    * Another class
    * Class-like functions
    * A normal function
    * A variable that contains a function or class
    * A property access on an object
    * A function call
    * `null`(if you don't want it to inherit from `Object.protoype`)
* You can access the parent properties via `super.xx` or `super[xx]`, and call parent constructor with `super()`(Note: therefore you need to initialize the parent explicitly)
* You can still access parent methods via `this`, if you don't overwrite them. But all accesses to `this` in subclass constructors that occur before the call to the super constructor will result in a `ReferenceError`.
* A convenient pattern: 

    ```
    constructor(...args) {
        super(...args);
    }
    ```
